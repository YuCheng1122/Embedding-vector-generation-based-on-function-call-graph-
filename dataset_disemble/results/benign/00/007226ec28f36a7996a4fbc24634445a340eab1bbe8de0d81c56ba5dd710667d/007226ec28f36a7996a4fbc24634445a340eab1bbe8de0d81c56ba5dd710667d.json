{
    "sym.camera_abilities": {
        "function_address": "0x00003610",
        "instructions": [
            "sub rsp, 0x9d8",
            "mov rdx, rdi",
            "mov ecx, 0x139",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x9c8], rax",
            "xor eax, eax",
            "mov rdi, rsp",
            "mov rsi, rsp",
            "sub rsp, 0x9d0",
            "rep stosq qword [rdi], rax",
            "movabs rax, 0x646c656966706f54",
            "mov dword [rsp + 0xa50], 2",
            "mov dword [rsp + 0xa54], 4",
            "mov qword [rsp + 0x9d0], rax",
            "movabs rax, 0x503030303546543a",
            "mov dword [rsp + 0xb64], 0x11db",
            "mov qword [rsp + 0x9d8], rax",
            "mov eax, 0x5256",
            "mov dword [rsp + 0xb68], 0x1000",
            "mov word [rsp + 0x9e0], ax",
            "mov dword [rsp + 0xb5c], 2",
            "mov rdi, rsp",
            "mov cx, 0x139",
            "rep movsq qword [rdi], qword [rsi]",
            "mov rdi, rdx",
            "call sym.imp.gp_abilities_list_append",
            "add rsp, 0x9d0",
            "mov rdx, qword [rsp + 0x9c8]",
            "xor rdx, qword fs:[0x28]",
            "jne 0x36de",
            "add rsp, 0x9d8",
            "ret",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "sym.imp.gp_abilities_list_append": {
        "function_address": "0x000016b0",
        "instructions": [
            "jmp qword [reloc.gp_abilities_list_append]"
        ]
    },
    "sym.imp.__stack_chk_fail": {
        "function_address": "0x000014a0",
        "instructions": [
            "jmp qword [reloc.__stack_chk_fail]"
        ]
    },
    "sym.camera_init": {
        "function_address": "0x000036f0",
        "instructions": [
            "push r12",
            "push rbp",
            "lea rcx, [0x00001f40]",
            "push rbx",
            "mov rax, qword [rdi + 0x10]",
            "lea rdx, [0x00001e10]",
            "mov rbx, rdi",
            "mov r12, rsi",
            "mov rdi, qword [rdi + 8]",
            "lea rsi, [0x00206040]",
            "mov qword [rax + 0x18], rcx",
            "lea rcx, [0x00001b50]",
            "mov qword [rax + 0x20], rdx",
            "lea rdx, [0x00001c00]",
            "mov qword [rax + 0x58], rcx",
            "lea rcx, [0x00001dd0]",
            "mov qword [rax + 0x68], rdx",
            "mov rdx, rbx",
            "mov qword [rax + 0x10], rcx",
            "call sym.imp.gp_filesystem_set_funcs",
            "mov rdi, qword [rbx]",
            "mov esi, 0x2af8",
            "call sym.imp.gp_port_set_timeout",
            "mov rdi, qword [rbx]",
            "xor esi, esi",
            "call sym.imp.gp_port_usb_clear_halt",
            "mov esi, 1",
            "mov edi, 0x10",
            "call sym.imp.calloc",
            "test rax, rax",
            "mov qword [rbx + 0x18], rax",
            "je 0x37e0",
            "mov edi, 0xe",
            "call sym.imp.nl_langinfo",
            "test rax, rax",
            "mov rbp, rax",
            "lea rax, str.UTF_8",
            "lea rsi, str.iso_8859_1",
            "cmove rbp, rax",
            "mov rdi, rbp",
            "call sym.imp.iconv_open",
            "test rax, rax",
            "mov qword [0x002061a0], rax",
            "je 0x37e0",
            "lea rdi, str.iso_8859_1",
            "mov rsi, rbp",
            "call sym.imp.iconv_open",
            "test rax, rax",
            "mov qword [0x002061a8], rax",
            "je 0x37e0",
            "mov rsi, r12",
            "mov rdi, rbx",
            "call fcn.00002100",
            "xor eax, eax",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "ret",
            "mov eax, 0xfffffffd",
            "jmp 0x37d9"
        ]
    },
    "sym.imp.gp_filesystem_set_funcs": {
        "function_address": "0x000015b0",
        "instructions": [
            "jmp qword [reloc.gp_filesystem_set_funcs]"
        ]
    },
    "sym.imp.gp_port_set_timeout": {
        "function_address": "0x000014d0",
        "instructions": [
            "jmp qword [reloc.gp_port_set_timeout]"
        ]
    },
    "sym.imp.gp_port_usb_clear_halt": {
        "function_address": "0x00001570",
        "instructions": [
            "jmp qword [reloc.gp_port_usb_clear_halt]"
        ]
    },
    "sym.imp.calloc": {
        "function_address": "0x00001520",
        "instructions": [
            "jmp qword [reloc.calloc]"
        ]
    },
    "sym.imp.nl_langinfo": {
        "function_address": "0x000015f0",
        "instructions": [
            "jmp qword [reloc.nl_langinfo]"
        ]
    },
    "sym.imp.iconv_open": {
        "function_address": "0x00001700",
        "instructions": [
            "jmp qword [reloc.iconv_open]"
        ]
    },
    "fcn.00002100": {
        "function_address": "0x00002100",
        "instructions": [
            "push r12",
            "push rbp",
            "mov rbp, rsi",
            "push rbx",
            "mov rbx, rdi",
            "sub rsp, 0x10010",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call fcn.00003930",
            "test eax, eax",
            "mov ecx, eax",
            "js 0x2178",
            "mov rdx, rbp",
            "mov rsi, rsp",
            "mov rdi, rbx",
            "call fcn.000040d0",
            "test eax, eax",
            "mov ecx, eax",
            "js 0x2178",
            "lea rdi, [rsp + 4]",
            "call fcn.00001880",
            "cmp eax, 1",
            "je 0x21c0",
            "cmp eax, 2",
            "jne 0x21a0",
            "lea rdx, str.Device_reports_ready._n",
            "lea rsi, str.topfield",
            "mov edi, 2",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "xor ecx, ecx",
            "nop dword [rax + rax]",
            "mov rdx, qword [rsp + 0x10008]",
            "xor rdx, qword fs:[0x28]",
            "mov eax, ecx",
            "jne 0x21e6",
            "add rsp, 0x10010",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "ret",
            "lea rdx, str.ERROR:_Unhandled_packet_n",
            "lea rsi, str.topfield",
            "xor edi, edi",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "mov ecx, 0xfffffff9",
            "jmp 0x2178",
            "mov rdi, rsp",
            "call fcn.00001b60",
            "lea rdx, str.ERROR:_Device_reports__s_n",
            "lea rsi, str.topfield",
            "mov rcx, rax",
            "xor edi, edi",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "xor ecx, ecx",
            "jmp 0x2178",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "fcn.00003930": {
        "function_address": "0x00003930",
        "instructions": [
            "push r12",
            "push rbp",
            "lea rdx, str.send_cmd_ready",
            "push rbx",
            "mov r12, rsi",
            "lea rsi, str.topfield",
            "mov rbp, rdi",
            "mov edi, 2",
            "sub rsp, 0x10010",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "mov esi, 8",
            "mov rdi, rsp",
            "call fcn.00001870",
            "lea rdi, [rsp + 4]",
            "mov esi, 0x100",
            "call fcn.000018e0",
            "mov rdx, r12",
            "mov rsi, rsp",
            "mov rdi, rbp",
            "call fcn.00003870",
            "mov rcx, qword [rsp + 0x10008]",
            "xor rcx, qword fs:[0x28]",
            "jne 0x39b5",
            "add rsp, 0x10010",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "ret",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "fcn.000040d0": {
        "function_address": "0x000040d0",
        "instructions": [
            "push r14",
            "mov r14, rdx",
            "push r13",
            "lea rdx, str.get_tf_packet",
            "push r12",
            "mov r12, rsi",
            "push rbp",
            "lea rsi, str.topfield",
            "push rbx",
            "xor eax, eax",
            "mov r13, rdi",
            "mov edi, 2",
            "call sym.imp.gp_log",
            "mov rdi, qword [r13]",
            "mov edx, 0xffff",
            "mov rsi, r12",
            "call sym.imp.gp_port_read",
            "test eax, eax",
            "mov ebx, eax",
            "js 0x41e1",
            "cmp eax, 7",
            "mov ecx, eax",
            "lea rdx, str.Short_read.__d_bytes_n",
            "jle 0x421a",
            "lea rbp, [r12 + 4]",
            "mov rdi, rbp",
            "call fcn.000018b0",
            "cmp eax, 0x100a",
            "je 0x4200",
            "mov rdi, r12",
            "call fcn.00001860",
            "movzx eax, ax",
            "add eax, 1",
            "and eax, 0xfffffffe",
            "cmp eax, 0x10000",
            "je 0x41f0",
            "test eax, eax",
            "je 0x4188",
            "mov rdx, r12",
            "nop dword [rax + rax]",
            "movzx r8d, byte [rdx]",
            "movzx r9d, byte [rdx + 1]",
            "add rdx, 2",
            "mov byte [rdx - 2], r9b",
            "mov byte [rdx - 1], r8b",
            "mov r8d, edx",
            "sub r8d, r12d",
            "cmp r8d, eax",
            "jl 0x4168",
            "mov rdi, r12",
            "call fcn.00001850",
            "cmp ax, 7",
            "jbe 0x4210",
            "lea rdi, [r12 + 2]",
            "call fcn.00001850",
            "mov rdi, r12",
            "mov r13d, eax",
            "call fcn.00001850",
            "movzx esi, ax",
            "mov rdi, rbp",
            "sub esi, 4",
            "movsxd rsi, esi",
            "call fcn.00001810",
            "cmp r13w, ax",
            "je 0x41e1",
            "lea rdx, str.WARNING:_Packet_CRC__04x__expected__04x_n",
            "lea rsi, str.topfield",
            "movzx r8d, ax",
            "movzx ecx, r13w",
            "xor edi, edi",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "movsxd rax, ebx",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "pop r14",
            "ret",
            "mov eax, 0xfffe",
            "jmp 0x4160",
            "mov rsi, r14",
            "mov rdi, r13",
            "call fcn.00003830",
            "jmp 0x4140",
            "lea rdx, str.Invalid_packet_length__04x_n",
            "movzx ecx, ax",
            "lea rsi, str.topfield",
            "xor eax, eax",
            "mov edi, 2",
            "call sym.imp.gp_log",
            "mov rax, 0xffffffffffffffff",
            "jmp 0x41e4"
        ]
    },
    "fcn.00001880": {
        "function_address": "0x00001880",
        "instructions": [
            "movzx eax, byte [rdi]",
            "shl eax, 0x18",
            "mov edx, eax",
            "movzx eax, byte [rdi + 1]",
            "shl eax, 0x10",
            "or eax, edx",
            "movzx edx, byte [rdi + 3]",
            "or eax, edx",
            "movzx edx, byte [rdi + 2]",
            "shl edx, 8",
            "or eax, edx",
            "ret"
        ]
    },
    "sym.imp.gp_log": {
        "function_address": "0x00001410",
        "instructions": [
            "jmp qword [reloc.gp_log]"
        ]
    },
    "fcn.00001b60": {
        "function_address": "0x00001b60",
        "instructions": [
            "sub rsp, 8",
            "add rdi, 8",
            "call fcn.00001880",
            "cmp eax, 7",
            "ja case.0x1b82.0",
            "lea rdx, [0x00004820]",
            "mov eax, eax",
            "movsxd rax, dword [rdx + rax*4]",
            "add rdx, rax",
            "jmp rdx",
            "lea rax, [0x000044a0]",
            "add rsp, 8",
            "ret",
            "lea rax, str.Unknown_command",
            "add rsp, 8",
            "ret",
            "lea rax, str.Invalid_command",
            "add rsp, 8",
            "ret",
            "lea rax, str.Invalid_block_size",
            "add rsp, 8",
            "ret",
            "lea rax, str.Unknown_error_while_running",
            "add rsp, 8",
            "ret",
            "lea rax, str.Memory_is_full",
            "add rsp, 8",
            "ret",
            "lea rax, str.Unknown_error_or_all_your_base_are_belong_to_us",
            "add rsp, 8",
            "ret"
        ]
    },
    "entry.fini0": {
        "function_address": "0x000017a0",
        "instructions": [
            "cmp byte [section..bss], 0",
            "jne 0x17d0",
            "cmp qword [reloc.__cxa_finalize], 0",
            "push rbp",
            "mov rbp, rsp",
            "je 0x17c3",
            "mov rdi, qword [section..data]",
            "call sym.imp.__cxa_finalize",
            "call entry0",
            "pop rbp",
            "mov byte [section..bss], 1",
            "repz ret"
        ]
    },
    "sym.imp.__cxa_finalize": {
        "function_address": "0x000016e0",
        "instructions": [
            "jmp qword [0x00205fb8]"
        ]
    },
    "rip": {
        "function_address": "0x00001710",
        "instructions": [
            "lea rdi, [section..bss]",
            "lea rax, [0x0020619f]",
            "push rbp",
            "sub rax, rdi",
            "mov rbp, rsp",
            "cmp rax, 0xe",
            "jbe 0x1740",
            "mov rax, qword [reloc._ITM_deregisterTMCloneTable]",
            "test rax, rax",
            "je 0x1740",
            "pop rbp",
            "jmp rax",
            "pop rbp",
            "ret"
        ]
    },
    "fcn.00003a50": {
        "function_address": "0x00003a50",
        "instructions": [
            "push r13",
            "push r12",
            "mov r13d, esi",
            "push rbp",
            "push rbx",
            "mov r12, rdx",
            "lea rsi, str.topfield",
            "lea rdx, str.send_cmd_turbo",
            "mov rbp, rdi",
            "sub rsp, 0x10018",
            "mov edi, 2",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "mov esi, 0xc",
            "mov rdi, rsp",
            "call fcn.00001870",
            "lea rdi, [rsp + 4]",
            "mov esi, 0x102",
            "call fcn.000018e0",
            "lea rdi, [rsp + 8]",
            "mov esi, r13d",
            "call fcn.000018e0",
            "mov rdx, r12",
            "mov rsi, rsp",
            "mov rdi, rbp",
            "call fcn.00003870",
            "mov rcx, qword [rsp + 0x10008]",
            "xor rcx, qword fs:[0x28]",
            "jne 0x3ae9",
            "add rsp, 0x10018",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "ret",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "fcn.00001870": {
        "function_address": "0x00001870",
        "instructions": [
            "mov eax, esi",
            "mov byte [rdi + 1], sil",
            "shr ax, 8",
            "mov byte [rdi], al",
            "ret"
        ]
    },
    "fcn.000018e0": {
        "function_address": "0x000018e0",
        "instructions": [
            "mov eax, esi",
            "mov byte [rdi + 3], sil",
            "shr eax, 0x18",
            "mov byte [rdi], al",
            "mov eax, esi",
            "shr eax, 0x10",
            "mov byte [rdi + 1], al",
            "mov eax, esi",
            "shr eax, 8",
            "mov byte [rdi + 2], al",
            "ret"
        ]
    },
    "fcn.00003870": {
        "function_address": "0x00003870",
        "instructions": [
            "push r12",
            "push rbp",
            "mov r12, rdi",
            "push rbx",
            "mov rdi, rsi",
            "mov rbx, rsi",
            "call fcn.00001850",
            "lea rdx, str.send_tf_packet",
            "lea rsi, str.topfield",
            "movzx ebp, ax",
            "mov edi, 2",
            "xor eax, eax",
            "add ebp, 1",
            "call sym.imp.gp_log",
            "mov rdi, rbx",
            "and ebp, 0xfffffffe",
            "call fcn.00001850",
            "movzx esi, ax",
            "lea rdi, [rbx + 4]",
            "sub esi, 4",
            "movsxd rsi, esi",
            "call fcn.00001810",
            "lea rdi, [rbx + 2]",
            "movzx esi, ax",
            "call fcn.00001870",
            "mov rdi, rbx",
            "call fcn.00001850",
            "movzx ecx, ax",
            "add ecx, 1",
            "mov eax, ecx",
            "and eax, 0xfffffffe",
            "je 0x3912",
            "sub eax, 1",
            "lea rcx, [rbx + 1]",
            "shr eax, 1",
            "lea rax, [rax + rax + 3]",
            "add rax, rbx",
            "nop dword [rax]",
            "movzx r8d, byte [rcx - 1]",
            "movzx r9d, byte [rcx]",
            "add rcx, 2",
            "mov byte [rcx - 3], r9b",
            "mov byte [rcx - 2], r8b",
            "cmp rcx, rax",
            "jne 0x38f8",
            "mov rdi, qword [r12]",
            "mov edx, ebp",
            "mov rsi, rbx",
            "call sym.imp.gp_port_write",
            "pop rbx",
            "cdqe",
            "pop rbp",
            "pop r12",
            "ret"
        ]
    },
    "fcn.00001850": {
        "function_address": "0x00001850",
        "instructions": [
            "movzx eax, byte [rdi]",
            "movzx edx, byte [rdi + 1]",
            "shl eax, 8",
            "or eax, edx",
            "ret"
        ]
    },
    "fcn.00001810": {
        "function_address": "0x00001810",
        "instructions": [
            "test rsi, rsi",
            "je 0x1843",
            "lea rcx, section..rodata",
            "add rsi, rdi",
            "xor eax, eax",
            "nop dword [rax]",
            "add rdi, 1",
            "mov edx, eax",
            "shr ax, 8",
            "xor dl, byte [rdi - 1]",
            "movzx edx, dl",
            "xor ax, word [rcx + rdx*2]",
            "cmp rdi, rsi",
            "jne 0x1828",
            "repz ret",
            "xor eax, eax",
            "ret"
        ]
    },
    "sym.imp.gp_port_write": {
        "function_address": "0x00001550",
        "instructions": [
            "jmp qword [reloc.gp_port_write]"
        ]
    },
    "sym.imp.gp_port_read": {
        "function_address": "0x00001640",
        "instructions": [
            "jmp qword [reloc.gp_port_read]"
        ]
    },
    "fcn.000018b0": {
        "function_address": "0x000018b0",
        "instructions": [
            "movzx eax, byte [rdi + 1]",
            "shl eax, 0x18",
            "mov edx, eax",
            "movzx eax, byte [rdi]",
            "shl eax, 0x10",
            "or eax, edx",
            "movzx edx, byte [rdi + 2]",
            "or eax, edx",
            "movzx edx, byte [rdi + 3]",
            "shl edx, 8",
            "or eax, edx",
            "ret"
        ]
    },
    "fcn.00001860": {
        "function_address": "0x00001860",
        "instructions": [
            "movzx eax, byte [rdi + 1]",
            "movzx edx, byte [rdi]",
            "shl eax, 8",
            "or eax, edx",
            "ret"
        ]
    },
    "fcn.00003830": {
        "function_address": "0x00003830",
        "instructions": [
            "push rbx",
            "lea rdx, str.send_success",
            "lea rsi, str.topfield",
            "mov rbx, rdi",
            "xor eax, eax",
            "mov edi, 2",
            "call sym.imp.gp_log",
            "mov rdi, qword [rbx]",
            "lea rsi, [0x00004a48]",
            "mov edx, 8",
            "call sym.imp.gp_port_write",
            "pop rbx",
            "cdqe",
            "ret"
        ]
    },
    "fcn.00003af0": {
        "function_address": "0x00003af0",
        "instructions": [
            "push r12",
            "push rbp",
            "lea rdx, str.send_cmd_hdd_size",
            "push rbx",
            "mov r12, rsi",
            "lea rsi, str.topfield",
            "mov rbp, rdi",
            "mov edi, 2",
            "sub rsp, 0x10010",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "mov esi, 8",
            "mov rdi, rsp",
            "call fcn.00001870",
            "lea rdi, [rsp + 4]",
            "mov esi, 0x1000",
            "call fcn.000018e0",
            "mov rdx, r12",
            "mov rsi, rsp",
            "mov rdi, rbp",
            "call fcn.00003870",
            "mov rcx, qword [rsp + 0x10008]",
            "xor rcx, qword fs:[0x28]",
            "jne 0x3b75",
            "add rsp, 0x10010",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "ret",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "fcn.00001c30": {
        "function_address": "0x00001c30",
        "instructions": [
            "push r13",
            "push r12",
            "mov r13, rdx",
            "push rbp",
            "push rbx",
            "mov rbp, rsi",
            "mov edx, 0xa",
            "xor esi, esi",
            "mov r12, rdi",
            "sub rsp, 0x10418",
            "mov rdi, rbp",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10408], rax",
            "xor eax, eax",
            "call sym.imp.strtol",
            "lea rdx, [rsp + 0x10000]",
            "lea rsi, str.turbo",
            "lea rdi, str.topfield",
            "mov rbx, rax",
            "call sym.imp.gp_setting_get",
            "test eax, eax",
            "mov ecx, eax",
            "jne 0x1c9a",
            "cmp byte [rsp + 0x10000], 0x6e",
            "je 0x1d50",
            "lea rdi, [0x00004515]",
            "mov rsi, rbp",
            "call sym.imp.strcasecmp",
            "test eax, eax",
            "mov eax, 1",
            "mov rdx, r13",
            "cmove ebx, eax",
            "mov rdi, r12",
            "mov esi, ebx",
            "call fcn.00003a50",
            "test eax, eax",
            "mov ecx, eax",
            "js 0x1d28",
            "mov rdx, r13",
            "mov rsi, rsp",
            "mov rdi, r12",
            "call fcn.000040d0",
            "test eax, eax",
            "mov ecx, eax",
            "js 0x1d28",
            "lea rdi, [rsp + 4]",
            "call fcn.00001880",
            "cmp eax, 1",
            "je 0x1d90",
            "cmp eax, 2",
            "jne 0x1d70",
            "lea rax, [0x00004515]",
            "lea rcx, [0x00004518]",
            "test ebx, ebx",
            "lea rdx, str.Turbo_mode:__s_n",
            "lea rsi, str.topfield",
            "mov edi, 2",
            "cmovne rcx, rax",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "xor ecx, ecx",
            "nop word [rax + rax]",
            "mov rbx, qword [rsp + 0x10408]",
            "xor rbx, qword fs:[0x28]",
            "mov eax, ecx",
            "jne 0x1dbc",
            "add rsp, 0x10418",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "ret",
            "cmp byte [rsp + 0x10001], 0x6f",
            "jne 0x1c9a",
            "cmp byte [rsp + 0x10002], 0",
            "je 0x1d28",
            "jmp 0x1c9a",
            "lea rdx, str.ERROR:_Unhandled_packet_n",
            "lea rsi, str.topfield",
            "xor edi, edi",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "mov ecx, 0xfffffff9",
            "jmp 0x1d28",
            "mov rdi, rsp",
            "call fcn.00001b60",
            "lea rdx, str.ERROR:_Device_reports__s_n",
            "lea rsi, str.topfield",
            "mov rcx, rax",
            "xor edi, edi",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "mov ecx, 0xfffffff9",
            "jmp 0x1d28",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "sym.imp.strtol": {
        "function_address": "0x00001580",
        "instructions": [
            "jmp qword [reloc.strtol]"
        ]
    },
    "sym.imp.gp_setting_get": {
        "function_address": "0x00001400",
        "instructions": [
            "jmp qword [reloc.gp_setting_get]"
        ]
    },
    "sym.imp.strcasecmp": {
        "function_address": "0x000013d0",
        "instructions": [
            "jmp qword [reloc.strcasecmp]"
        ]
    },
    "fcn.000023c0": {
        "function_address": "0x000023c0",
        "instructions": [
            "push r15",
            "push r14",
            "push r13",
            "push r12",
            "mov r13, rsi",
            "push rbp",
            "push rbx",
            "mov rbx, rdx",
            "xor ebp, ebp",
            "sub rsp, 0x58",
            "mov qword [rsp + 0x18], rdi",
            "mov rdi, rsi",
            "lea r15, [rsp + 0x30]",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x48], rax",
            "xor eax, eax",
            "call sym.imp.strlen",
            "lea rcx, [rsp + 0x28]",
            "lea r12, [rax + rax]",
            "lea r14, [rsp + 0x40]",
            "mov qword [rsp + 8], rcx",
            "lea rcx, [rsp + 0x38]",
            "mov qword [rsp + 0x10], rcx",
            "add rax, 1",
            "mov rdi, rbp",
            "mov qword [rsp + 0x38], r13",
            "mov qword [rsp + 0x28], rax",
            "mov qword [rsp + 0x30], r12",
            "call sym.imp.free",
            "mov esi, 1",
            "mov rdi, r12",
            "call sym.imp.calloc",
            "test rax, rax",
            "mov rbp, rax",
            "mov qword [rsp + 0x40], rax",
            "je 0x248a",
            "mov rdx, qword [rsp + 8]",
            "mov rsi, qword [rsp + 0x10]",
            "mov r8, r15",
            "mov rdi, qword [0x002061a8]",
            "mov rcx, r14",
            "call sym.imp.iconv",
            "cmp rax, 0xffffffffffffffff",
            "jne 0x24c8",
            "call sym.imp.__errno_location",
            "cmp dword [rax], 7",
            "je 0x24b8",
            "lea rdi, str.iconv",
            "call sym.imp.perror",
            "mov rdi, rbp",
            "call sym.imp.free",
            "xor eax, eax",
            "nop dword [rax]",
            "mov rcx, qword [rsp + 0x48]",
            "xor rcx, qword fs:[0x28]",
            "jne 0x25df",
            "add rsp, 0x58",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "pop r14",
            "pop r15",
            "ret",
            "mov rdi, r13",
            "add r12, r12",
            "call sym.imp.strlen",
            "jmp 0x2415",
            "mov rax, qword [rsp + 0x18]",
            "mov rax, qword [rax + 0x18]",
            "mov r13d, dword [rax + 8]",
            "test r13d, r13d",
            "jle 0x25d0",
            "mov r12, qword [rax]",
            "sub r13d, 1",
            "add r13, 1",
            "shl r13, 4",
            "add r13, r12",
            "jmp 0x2505",
            "add r12, 0x10",
            "cmp r12, r13",
            "je 0x25d0",
            "mov rsi, qword [r12 + 8]",
            "mov rdi, rbx",
            "call sym.imp.strcmp",
            "test eax, eax",
            "jne 0x24f8",
            "mov r13, qword [r12]",
            "test r13, r13",
            "je 0x25d0",
            "mov rbx, rbp",
            "mov edx, dword [rbx]",
            "add rbx, 4",
            "lea eax, [rdx - 0x1010101]",
            "not edx",
            "and eax, edx",
            "and eax, 0x80808080",
            "je 0x2526",
            "mov edx, eax",
            "mov rdi, r13",
            "shr edx, 0x10",
            "test eax, 0x8080",
            "cmove eax, edx",
            "lea rdx, [rbx + 2]",
            "cmove rbx, rdx",
            "add al, al",
            "sbb rbx, 3",
            "sub rbx, rbp",
            "call sym.imp.strlen",
            "lea rdi, [rbx + rax + 2]",
            "call sym.imp.malloc",
            "test rax, rax",
            "mov r12, rax",
            "je 0x25d0",
            "mov rdx, rbx",
            "mov rsi, rbp",
            "mov rdi, rax",
            "call sym.imp.memcpy",
            "mov eax, 0x2f",
            "mov word [r12 + rbx], ax",
            "mov rax, r12",
            "jmp 0x259b",
            "mov byte [rax], 0x5c",
            "mov esi, 0x2f",
            "mov rdi, rax",
            "call sym.imp.strchr",
            "test rax, rax",
            "jne 0x2598",
            "mov rsi, r13",
            "mov rdi, r12",
            "call sym.imp.strcat",
            "mov rdi, rbp",
            "call sym.imp.free",
            "mov rdi, r13",
            "call sym.imp.free",
            "mov rax, r12",
            "jmp 0x2490",
            "mov rdi, rbp",
            "call sym.imp.free",
            "xor eax, eax",
            "jmp 0x2490",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "sym.imp.strlen": {
        "function_address": "0x00001490",
        "instructions": [
            "jmp qword [reloc.strlen]"
        ]
    },
    "sym.imp.free": {
        "function_address": "0x000013c0",
        "instructions": [
            "jmp qword [reloc.free]"
        ]
    },
    "sym.imp.iconv": {
        "function_address": "0x00001440",
        "instructions": [
            "jmp qword [reloc.iconv]"
        ]
    },
    "sym.imp.__errno_location": {
        "function_address": "0x000013f0",
        "instructions": [
            "jmp qword [reloc.__errno_location]"
        ]
    },
    "sym.imp.perror": {
        "function_address": "0x00001670",
        "instructions": [
            "jmp qword [reloc.perror]"
        ]
    },
    "sym.imp.strcmp": {
        "function_address": "0x00001540",
        "instructions": [
            "jmp qword [reloc.strcmp]"
        ]
    },
    "sym.imp.malloc": {
        "function_address": "0x000015e0",
        "instructions": [
            "jmp qword [reloc.malloc]"
        ]
    },
    "sym.imp.memcpy": {
        "function_address": "0x00001590",
        "instructions": [
            "jmp qword [reloc.memcpy]"
        ]
    },
    "sym.imp.strchr": {
        "function_address": "0x000014c0",
        "instructions": [
            "jmp qword [reloc.strchr]"
        ]
    },
    "sym.imp.strcat": {
        "function_address": "0x00001690",
        "instructions": [
            "jmp qword [reloc.strcat]"
        ]
    },
    "fcn.00003c70": {
        "function_address": "0x00003c70",
        "instructions": [
            "push r15",
            "push r14",
            "mov r15d, esi",
            "push r13",
            "push r12",
            "mov r13, rdi",
            "push rbp",
            "push rbx",
            "mov rdi, rdx",
            "mov r12, rdx",
            "mov r14, rcx",
            "sub rsp, 0x10018",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call sym.imp.strlen",
            "lea rdx, str.send_cmd_hdd_file_send_dir___d__path___s_",
            "lea ebx, [rax + 1]",
            "lea rsi, str.topfield",
            "xor eax, eax",
            "movzx ecx, r15b",
            "mov r8, r12",
            "mov edi, 2",
            "call sym.imp.gp_log",
            "cmp ebx, 0xfff3",
            "jg 0x3d50",
            "lea esi, [rbx + 0xc]",
            "mov rdi, rsp",
            "and esi, 0xfffe",
            "call fcn.00001870",
            "lea rdi, [rsp + 4]",
            "mov esi, 0x1008",
            "call fcn.000018e0",
            "lea rdi, [rsp + 9]",
            "movzx esi, bx",
            "mov byte [rsp + 8], r15b",
            "call fcn.00001870",
            "lea rdi, [rsp + 0xb]",
            "mov edx, 0xfff4",
            "mov rsi, r12",
            "call sym.imp.__strcpy_chk",
            "mov rdx, r14",
            "mov rsi, rsp",
            "mov rdi, r13",
            "call fcn.00003870",
            "mov rbx, qword [rsp + 0x10008]",
            "xor rbx, qword fs:[0x28]",
            "jne 0x3d79",
            "add rsp, 0x10018",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "pop r14",
            "pop r15",
            "ret",
            "mov rax, qword [reloc.stderr]",
            "lea rdi, str.ERROR:_Path_is_too_long._n",
            "mov edx, 0x19",
            "mov esi, 1",
            "mov rcx, qword [rax]",
            "call sym.imp.fwrite",
            "mov rax, 0xffffffffffffffff",
            "jmp 0x3d26",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "sym.imp.__strcpy_chk": {
        "function_address": "0x00001630",
        "instructions": [
            "jmp qword [reloc.__strcpy_chk]"
        ]
    },
    "sym.imp.fwrite": {
        "function_address": "0x000016a0",
        "instructions": [
            "jmp qword [reloc.fwrite]"
        ]
    },
    "fcn.000037f0": {
        "function_address": "0x000037f0",
        "instructions": [
            "push rbx",
            "lea rdx, str.send_cancel",
            "lea rsi, str.topfield",
            "mov rbx, rdi",
            "xor eax, eax",
            "mov edi, 2",
            "call sym.imp.gp_log",
            "mov rdi, qword [rbx]",
            "lea rsi, [0x00004a50]",
            "mov edx, 8",
            "call sym.imp.gp_port_write",
            "pop rbx",
            "cdqe",
            "ret"
        ]
    },
    "fcn.000019b0": {
        "function_address": "0x000019b0",
        "instructions": [
            "push rbx",
            "mov rbx, rdi",
            "sub rsp, 0x40",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x38], rax",
            "xor eax, eax",
            "call fcn.00001850",
            "pxor xmm0, xmm0",
            "movzx eax, ax",
            "movsd xmm1, qword [0x00004488]",
            "xor r8d, r8d",
            "mov dword [rsp + 0x18], 0",
            "mov dword [rsp + 0x1c], 0",
            "cvtsi2sd xmm0, eax",
            "mov dword [rsp + 0x20], 0xffffffff",
            "movapd xmm2, xmm0",
            "subsd xmm0, qword [0x00004490]",
            "subsd xmm2, qword [0x00004480]",
            "divsd xmm2, xmm1",
            "cvttsd2si esi, xmm2",
            "pxor xmm2, xmm2",
            "cvtsi2sd xmm2, esi",
            "mulsd xmm1, xmm2",
            "cvttsd2si ecx, xmm1",
            "pxor xmm1, xmm1",
            "cvtsi2sd xmm1, ecx",
            "subsd xmm0, xmm1",
            "movsd xmm1, qword [0x00004498]",
            "divsd xmm0, xmm1",
            "cvttsd2si edx, xmm0",
            "pxor xmm0, xmm0",
            "cvtsi2sd xmm0, edx",
            "lea edi, [rdx - 0xe]",
            "cmp edi, 1",
            "movzx edi, byte [rbx + 4]",
            "setbe r8b",
            "sub eax, 0x3a6c",
            "sub eax, ecx",
            "add esi, r8d",
            "mov dword [rsp + 0x14], esi",
            "mov dword [rsp], edi",
            "movzx edi, byte [rbx + 3]",
            "mov dword [rsp + 4], edi",
            "movzx edi, byte [rbx + 2]",
            "mulsd xmm1, xmm0",
            "mov dword [rsp + 8], edi",
            "mov rdi, rsp",
            "cvttsd2si ecx, xmm1",
            "sub eax, ecx",
            "mov dword [rsp + 0xc], eax",
            "lea eax, [r8 + r8]",
            "add eax, r8d",
            "shl eax, 2",
            "neg eax",
            "lea eax, [rdx + rax - 2]",
            "mov dword [rsp + 0x10], eax",
            "call sym.imp.mktime",
            "mov rdx, qword [rsp + 0x38]",
            "xor rdx, qword fs:[0x28]",
            "jne 0x1aba",
            "add rsp, 0x40",
            "pop rbx",
            "ret",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "sym.imp.mktime": {
        "function_address": "0x00001600",
        "instructions": [
            "jmp qword [reloc.mktime]"
        ]
    },
    "fcn.00003d80": {
        "function_address": "0x00003d80",
        "instructions": [
            "push r14",
            "push r13",
            "mov r13, rdx",
            "push r12",
            "push rbp",
            "mov r12, rdi",
            "push rbx",
            "mov rdi, rsi",
            "mov rbp, rsi",
            "sub rsp, 0x10010",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call sym.imp.strlen",
            "lea rdx, str.send_cmd_hdd_del",
            "lea ebx, [rax + 1]",
            "lea rsi, str.topfield",
            "xor eax, eax",
            "mov edi, 2",
            "call sym.imp.gp_log",
            "cmp ebx, 0xfff6",
            "jg 0x3e40",
            "add ebx, 9",
            "mov rdi, rsp",
            "mov esi, ebx",
            "and esi, 0xfffe",
            "call fcn.00001870",
            "lea rdi, [rsp + 4]",
            "mov esi, 0x1005",
            "call fcn.000018e0",
            "lea rdi, [rsp + 8]",
            "mov edx, 0xfff7",
            "mov rsi, rbp",
            "call sym.imp.__strcpy_chk",
            "mov rdx, r13",
            "mov rsi, rsp",
            "mov rdi, r12",
            "call fcn.00003870",
            "mov rcx, qword [rsp + 0x10008]",
            "xor rcx, qword fs:[0x28]",
            "jne 0x3e69",
            "add rsp, 0x10010",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "pop r14",
            "ret",
            "mov rax, qword [reloc.stderr]",
            "lea rdi, str.ERROR:_Path_is_too_long._n",
            "mov edx, 0x19",
            "mov esi, 1",
            "mov rcx, qword [rax]",
            "call sym.imp.fwrite",
            "mov rax, 0xffffffffffffffff",
            "jmp 0x3e1a",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "fcn.00003fc0": {
        "function_address": "0x00003fc0",
        "instructions": [
            "push r15",
            "push r14",
            "push r13",
            "push r12",
            "mov r12, rdi",
            "push rbp",
            "push rbx",
            "mov rdi, rsi",
            "mov rbp, rsi",
            "mov r13, rdx",
            "sub rsp, 0x10018",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call sym.imp.strlen",
            "lea rdx, str.send_cmd_hdd_create_dir",
            "lea r15d, [rax + 1]",
            "lea rsi, str.topfield",
            "mov rbx, rax",
            "mov edi, 2",
            "xor eax, eax",
            "call sym.imp.gp_log",
            "cmp r15w, 0xfff4",
            "movzx r14d, r15w",
            "ja 0x4098",
            "add ebx, 0xc",
            "mov rdi, rsp",
            "mov esi, ebx",
            "and esi, 0xfffe",
            "call fcn.00001870",
            "lea rdi, [rsp + 4]",
            "mov esi, 0x1007",
            "call fcn.000018e0",
            "lea rdi, [rsp + 8]",
            "mov esi, r14d",
            "call fcn.00001870",
            "lea rdi, [rsp + 0xa]",
            "mov edx, 0xfff5",
            "mov rsi, rbp",
            "call sym.imp.__strcpy_chk",
            "mov rdx, r13",
            "mov rsi, rsp",
            "mov rdi, r12",
            "call fcn.00003870",
            "mov rcx, qword [rsp + 0x10008]",
            "xor rcx, qword fs:[0x28]",
            "jne 0x40c1",
            "add rsp, 0x10018",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "pop r14",
            "pop r15",
            "ret",
            "mov rax, qword [reloc.stderr]",
            "lea rdi, str.ERROR:_Path_is_too_long._n",
            "mov edx, 0x19",
            "mov esi, 1",
            "mov rcx, qword [rax]",
            "call sym.imp.fwrite",
            "mov rax, 0xffffffffffffffff",
            "jmp 0x4070",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "fcn.00002c10": {
        "function_address": "0x00002c10",
        "instructions": [
            "push r15",
            "push r14",
            "push r13",
            "push r12",
            "mov r13, rdi",
            "push rbp",
            "push rbx",
            "mov rbx, rsi",
            "sub rsp, 0x58",
            "mov r14, qword [rdi]",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x48], rax",
            "xor eax, eax",
            "mov r12d, dword [r14 + 8]",
            "mov rax, qword [r14]",
            "test r12d, r12d",
            "mov qword [rsp + 8], rax",
            "jle 0x2ca0",
            "lea ebp, [r12 - 1]",
            "mov r15, rax",
            "add rbp, 1",
            "shl rbp, 4",
            "add rbp, rax",
            "jmp 0x2c69",
            "add r15, 0x10",
            "cmp r15, rbp",
            "je 0x2ca0",
            "mov rsi, qword [r15]",
            "mov rdi, rbx",
            "call sym.imp.strcmp",
            "test eax, eax",
            "jne 0x2c60",
            "mov rax, qword [r15 + 8]",
            "mov rdx, qword [rsp + 0x48]",
            "xor rdx, qword fs:[0x28]",
            "jne 0x2dea",
            "add rsp, 0x58",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "pop r14",
            "pop r15",
            "ret",
            "lea esi, [r12 + 1]",
            "mov rdi, qword [rsp + 8]",
            "lea r15, [rsp + 0x30]",
            "movsxd rsi, esi",
            "shl rsi, 4",
            "call sym.imp.realloc",
            "mov qword [r14], rax",
            "mov rax, qword [r13]",
            "mov rdi, rbx",
            "movsxd r12, dword [rax + 8]",
            "shl r12, 4",
            "add r12, qword [rax]",
            "call sym.imp.__strdup",
            "mov qword [r12], rax",
            "xor eax, eax",
            "cmp byte [rbx], 5",
            "sete al",
            "xor ebp, ebp",
            "add rbx, rax",
            "mov rdi, rbx",
            "call sym.imp.strlen",
            "lea rcx, [rsp + 0x38]",
            "lea rdx, [rsp + 0x28]",
            "lea r14, [rax + rax + 1]",
            "mov qword [rsp + 8], rcx",
            "lea rcx, [rsp + 0x40]",
            "mov qword [rsp + 0x10], rdx",
            "mov qword [rsp + 0x18], rcx",
            "add rax, 1",
            "mov rdi, rbp",
            "mov qword [rsp + 0x40], rbx",
            "mov qword [rsp + 0x28], rax",
            "mov qword [rsp + 0x30], r14",
            "call sym.imp.free",
            "mov rdi, r14",
            "call sym.imp.malloc",
            "test rax, rax",
            "mov rbp, rax",
            "mov qword [rsp + 0x38], rax",
            "je 0x2d83",
            "mov rcx, qword [rsp + 8]",
            "mov rdx, qword [rsp + 0x10]",
            "mov r8, r15",
            "mov rsi, qword [rsp + 0x18]",
            "mov rdi, qword [0x002061a0]",
            "call sym.imp.iconv",
            "cmp rax, 0xffffffffffffffff",
            "jne 0x2db0",
            "call sym.imp.__errno_location",
            "cmp dword [rax], 7",
            "je 0x2da0",
            "lea rdi, str.iconv",
            "call sym.imp.perror",
            "mov rdi, rbp",
            "call sym.imp.free",
            "xor eax, eax",
            "mov qword [r12 + 8], rax",
            "mov rdx, qword [r13]",
            "add dword [rdx + 8], 1",
            "jmp 0x2c7c",
            "mov rdi, rbx",
            "add r14, r14",
            "call sym.imp.strlen",
            "jmp 0x2d11",
            "mov qword [rsp + 0x40], rbp",
            "mov rdi, rbp",
            "jmp 0x2dd1",
            "mov byte [rax], 0x2d",
            "mov rax, qword [rsp + 0x40]",
            "lea rdi, [rax + 1]",
            "mov qword [rsp + 0x40], rdi",
            "mov esi, 0x2f",
            "call sym.imp.strchr",
            "test rax, rax",
            "mov qword [rsp + 0x40], rax",
            "jne 0x2dc0",
            "mov rax, rbp",
            "jmp 0x2d85",
            "call sym.imp.__stack_chk_fail"
        ]
    },
    "sym.imp.realloc": {
        "function_address": "0x00001620",
        "instructions": [
            "jmp qword [reloc.realloc]"
        ]
    },
    "sym.imp.__strdup": {
        "function_address": "0x00001500",
        "instructions": [
            "jmp qword [reloc.__strdup]"
        ]
    },
    "fcn.00003b80": {
        "function_address": "0x00003b80",
        "instructions": [
            "push r14",
            "push r13",
            "mov r13, rdx",
            "push r12",
            "push rbp",
            "mov r12, rdi",
            "push rbx",
            "mov rdi, rsi",
            "mov rbp, rsi",
            "sub rsp, 0x10010",
            "mov rax, qword fs:[0x28]",
            "mov qword [rsp + 0x10008], rax",
            "xor eax, eax",
            "call sym.imp.strlen",
            "lea rdx, str.send_cmd_hdd_dir",
            "lea ebx, [rax + 1]",
            "lea rsi, str.topfield",
            "xor eax, eax",
            "mov edi, 2",
            "call sym.imp.gp_log",
            "cmp ebx, 0xfff6",
            "jg 0x3c40",
            "add ebx, 9",
            "mov rdi, rsp",
            "mov esi, ebx",
            "and esi, 0xfffe",
            "call fcn.00001870",
            "lea rdi, [rsp + 4]",
            "mov esi, 0x1002",
            "call fcn.000018e0",
            "lea rdi, [rsp + 8]",
            "mov edx, 0xfff7",
            "mov rsi, rbp",
            "call sym.imp.__strcpy_chk",
            "mov rdx, r13",
            "mov rsi, rsp",
            "mov rdi, r12",
            "call fcn.00003870",
            "mov rcx, qword [rsp + 0x10008]",
            "xor rcx, qword fs:[0x28]",
            "jne 0x3c69",
            "add rsp, 0x10010",
            "pop rbx",
            "pop rbp",
            "pop r12",
            "pop r13",
            "pop r14",
            "ret",
            "mov rax, qword [reloc.stderr]",
            "lea rdi, str.ERROR:_Path_is_too_long._n",
            "mov edx, 0x19",
            "mov esi, 1",
            "mov rcx, qword [rax]",
            "call sym.imp.fwrite",
            "mov rax, 0xffffffffffffffff",
            "jmp 0x3c1a",
            "call sym.imp.__stack_chk_fail"
        ]
    }
}